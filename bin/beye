#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Copyright 2013 by László Nagy
# This file is part of Beye [see file LICENSE.txt for more]

import os
import logging
import multiprocessing
import json

import analyzer


def main():
    from argparse import ArgumentParser
    parser = ArgumentParser()
    parser.add_argument("--output",
                        metavar='DIR',
                        help="Specify output directory\
                              (default generated)")
    parser.add_argument("--input",
                        metavar='FILE',
                        default="compile_commands.json",
                        help="The JSON compilation database\
                              (default compile_commands.json)")
    parser.add_argument("--sequential",
                        action='store_true',
                        help="execute analyzer sequentialy (default false)")
    parser.add_argument('--log-level',
                        metavar='LEVEL',
                        choices='DEBUG INFO WARNING ERROR'.split(),
                        default='WARNING',
                        help="Choose a log level from DEBUG, INFO, WARNING,\
                              (default) or ERROR")
    args = parser.parse_args()

    logging.basicConfig(format='%(levelname)s: %(message)s',
                        level=args.log_level)

    try:
        out_dir = create_out_directory(args.output)

        with open(args.input, "r") as fd:
            if args.sequential:
                for c in json.load(fd):
                    analyze(c, out_dir)
            else:
                pool = multiprocessing.Pool()
                results = [pool.apply_async(func=analyze, args=(c, out_dir))
                           for c in json.load(fd)]

                pool.close()
                pool.join()

    finally:
        cleanup_out_directory(out_dir)


def analyze(task, out_dir):
    task['html_dir']=out_dir
    task['output_format']='html'
    return analyzer.run(**task)


def create_out_directory(hint):
    if (hint):
        try:
            os.mkdir(hint)
        except OSError as ex:
            if ex.errno != 17:  # Already exists
                raise

        result = hint
    else:
        import tempfile
        result = tempfile.mkdtemp(prefix='beye-')

    logging.debug('output directory: {}'.format(result))
    return result


def cleanup_out_directory(dir):
    try:
        os.removedirs(dir)
    except OSError as ex:
        if ex.errno != 39:  # Directory not empty
            raise


# entry symbol
if __name__ == '__main__':
    multiprocessing.freeze_support()
    main()
